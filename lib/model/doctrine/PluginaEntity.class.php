<?php

/**
 * PluginaEntity
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
abstract class PluginaEntity extends BaseaEntity
{
	/**
	 * limit and offset options. Returns posts in reverse chrono order
	 */
  public function getSortedPosts($options)
  {
  	return $this->getSortedBlogItems(array_merge($options, array('blogItemType' => 'post')));
  }

  /**
   * limit and offset options. Returns upcoming events in forward chrono order
   */
  public function getSortedEvents($options)
  {
  	return $this->getSortedBlogItems(array_merge($options, array('blogItemType' => 'event')));
  }

  /**
   *
   * Obtain blog posts and events relating to an entity, with their virtual pages
   * hydrated and ready to use.
   *
   * limit, offset and blogItemType options accepted. blogItemType can be post or event.
   * Sort is reverse chronological unles blogItemType is event, in which case 
   * upcoming events in forward chronological order are returned
   *
   * You want to use a reasonably conservative limit as hydrating pages is expensive.
   */
  public function getSortedBlogItems($options)
  {
  	$limit = isset($options['limit']) ? $options['limit'] : null;
  	$offset = $offset = isset($options['offset']) ? $options['offset'] : null;
  	$blogItemType = isset($options['blogItemType']) ? $options['blogItemType'] : null;
  	$q = Doctrine::getTable('aBlogItem')->createQuery('p')->addWhere('p.status = "published"');
  	$q->innerJoin('p.Entities e WITH e.id = ?', $this->id);
  	if ($blogItemType === 'event')
  	{
  		$q->andWhere('p.start_date >= NOW() OR (p.start_date <= NOW() AND p.end_date >= NOW())');
  		$q->orderBy('p.start_date asc');
  	}
  	else
  	{
  		$q->orderBy('p.published_at desc');
  	}
  	if (!is_null($blogItemType))
  	{
  		$q->where('p.type = ?', $blogItemType);
  	}
		if (!is_null($limit))
		{
			$q->limit($limit);
		}    	
		if (!is_null($offset))
		{
			$q->offset($offset);
		}
		$posts = $q->execute();
		aBlogItemTable::populatePages($posts);
		return $posts;
  }

  /**
   * Return all related entities, grouped by subclass, sorted
   * in their preferred order via their comparators. Refactored to
   * the table class to support array hydration
   */
  public function groupEntitiesBySubclass()
  {
    return aEntityTable::groupEntitiesBySubclass($this);
  }

  /**
   * Get all related entities of a particular subclass. Now
   * utilizes groupEntitiesBySubclass and uses the preferred
   * comparator for the subclass. Refactored to
   * the table class to support array hydration
   */
  public function getEntitiesBySubclass($subclass)
  {
    return aEntityTable::getEntitiesBySubclass($this, $subclass);
    $entitiesBySubclass = $this->groupEntitiesBySubclass();
    return $entitiesBySubclass[$subclass];
  }

  /**
   * Used to generate random entities in the
   * apostrophe:generate-test-entities task.
   * Override this method to set additional fields unique
   * to your entity, set more appropriate names, etc.
   */
  public function randomize($wordSource)
  {
    $this->setName(implode(' ', $wordSource->getWords(mt_rand(1, 5))));
  }
}
