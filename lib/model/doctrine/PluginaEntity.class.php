<?php

/**
 * PluginaEntity
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
abstract class PluginaEntity extends BaseaEntity
{
	/**
	 * limit and offset options. Returns posts in reverse chrono order
	 */
  public function getSortedPosts($options)
  {
  	return $this->getSortedBlogItems(array_merge($options, array('blogItemType' => 'post')));
  }

  /**
   * limit and offset options. Returns upcoming events in forward chrono order
   */
  public function getSortedEvents($options)
  {
  	return $this->getSortedBlogItems(array_merge($options, array('blogItemType' => 'event')));
  }

  /**
   *
   * Obtain blog posts and events relating to an entity, with their virtual pages
   * hydrated and ready to use.
   *
   * limit, offset and blogItemType options accepted. blogItemType can be post or event.
   * Sort is reverse chronological unles blogItemType is event, in which case 
   * upcoming events in forward chronological order are returned
   *
   * You want to use a reasonably conservative limit as hydrating pages is expensive.
   *
   * If you specify 'array' => true, you'll get back an array a lot more
   * cheaply, but you won't have access to the body of any post or event,
   * and the title will be that most recently set for any language on this
   * post (most folks turn out not to internationalize individual events,
   * so this isn't much of a problem).
   */
  public function getSortedBlogItems($options)
  {
    $array = isset($options['array']) ? $options['array'] : null;
  	$limit = isset($options['limit']) ? $options['limit'] : null;
  	$offset = $offset = isset($options['offset']) ? $options['offset'] : null;
  	$blogItemType = isset($options['blogItemType']) ? $options['blogItemType'] : null;
    
    // Fetch posts by a particular author rather than related to a 
    // particular entity. It's the difference between being the 
    // journalist and being the subject of the piece. This lives here 
    // because it is useful when the entity has an 'owner_id' column 
    // relating it to an sfGuardUser. But not every project will, so 
    // we don't hardcode that part.
    $byAuthorId = isset($options['byAuthorId']) ? $options['byAuthorId'] : null;

  	$q = Doctrine::getTable('aBlogItem')->createQuery('p')->addWhere('p.status = "published"');
    if ($byAuthorId)
    {
      $q->andWhere('p.author_id = ?', $byAuthorId);
    }
    else
    {
      $q->innerJoin('p.Entities e WITH e.id = ?', $this->id);
    }
  	if ($blogItemType === 'event')
  	{
  		$q->andWhere('p.start_date >= NOW() OR (p.start_date <= NOW() AND p.end_date >= NOW())');
  		$q->orderBy('p.start_date asc');
  	}
  	else
  	{
  		$q->orderBy('p.published_at desc');
  	}
  	if (!is_null($blogItemType))
  	{
  		$q->where('p.type = ?', $blogItemType);
  	}
		if (!is_null($limit))
		{
			$q->limit($limit);
		}    	
		if (!is_null($offset))
		{
			$q->offset($offset);
		}
    if ($array) 
    {
      return $q->fetchArray();
    }
		$posts = $q->execute();
		aBlogItemTable::populatePages($posts);
		return $posts;
  }

  /**
   * Return all related entities, grouped by subclass, sorted
   * in their preferred order via their comparators. Refactored to
   * the table class to support array hydration
   */
  public function groupEntitiesBySubclass()
  {
    return aEntityTable::groupEntitiesBySubclass($this);
  }

  /**
   * Get all related entities of a particular subclass. Now
   * utilizes groupEntitiesBySubclass and uses the preferred
   * comparator for the subclass. Refactored to
   * the table class to support array hydration
   */
  public function getEntitiesBySubclass($subclass)
  {
    return aEntityTable::getEntitiesBySubclass($this, $subclass);
    $entitiesBySubclass = $this->groupEntitiesBySubclass();
    return $entitiesBySubclass[$subclass];
  }

  /**
   * Used to generate random entities in the
   * apostrophe:generate-test-entities task.
   * Override this method to set additional fields unique
   * to your entity, set more appropriate names, etc.
   */
  public function randomize($wordSource)
  {
    $this->setName(implode(' ', $wordSource->getWords(mt_rand(1, 5))));
  }
}
